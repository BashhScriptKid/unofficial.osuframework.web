<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Scheduling | osu!framework </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Scheduling | osu!framework ">
      
      
      <link rel="icon" href="../assets/nuget icon.png">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://github.com/ppy/osu-framework.wiki/blob/master/Threading.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../assets/docfx_icon.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">

<p>With regard to threading, osu!framework games can run in two modes:</p>
<ul>
<li><p>In <em>multi-threaded</em> execution mode, the game is ran on four main threads:</p>
<ol>
<li>The input thread:
<ul>
<li>usually runs at 1000Hz</li>
<li>interfaces with the windowing toolkit used (SDL2 by default, osuTK also available)</li>
<li>responsible for handling input events and forwarding them to components/drawables</li>
</ul>
</li>
<li>The audio thread:
<ul>
<li>usually runs at 1000Hz</li>
<li>interfaces with the audio subsystem of the OS via the BASS audio library</li>
</ul>
</li>
<li>The update thread:
<ul>
<li>usually runs at twice the framerate limit (which can be toggled using the <code>FrameSync</code> framework setting, or the <kbd>Ctrl</kbd>+<kbd>F7</kbd> shortcut)</li>
<li>is responsible for running update code (<code>UpdateSubTree()</code>, <code>Update()</code>) for all components in the game's drawable hierarchy</li>
</ul>
</li>
<li>The draw thread:
<ul>
<li>runs at the framerate limit specified</li>
<li>dispatches draw calls to the GPU (currently using OpenGL, more backends planned in the future)</li>
</ul>
</li>
</ol>
</li>
<li><p>In <em>single-thread</em> execution mode, the four threads above run on one OS thread in an interleaved fashion.</p>
</li>
</ul>
<p>The threading mode can be set using the <code>ExecutionMode</code> framework setting, or using the <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>F7</kbd> shortcut.</p>
<p>Note that in either mode, it is possible that other tasks, such as asynchronous loads of drawables via <code>CompositeDrawable.LoadComponentAsync()</code> (see <a href="https://github.com/ppy/osu-framework/wiki/Asynchronous-loading">docs on asynchronous loading</a>), or <code>Task</code>s running on the .NET runtime's thread pool, can use additional OS threads.</p>
<h1 id="scheduling">Scheduling</h1>
<p>Relatively often, there is a need to change the state of a <code>Drawable</code> or <code>Component</code> in response from a callback which is not executing on the game's update thread.
An example of this would be updating the text and transforms to a <code>SpriteText</code> in response to a web request.
To ensure that such an operation can be executed in a safe manner, each <code>Drawable</code> or <code>Component</code> has an internal <code>Scheduler</code>, that can collect such pending operations and execute them at the correct time:</p>
<pre><code class="lang-csharp">request = CreateRequest();
request.Failure += exception =&gt; Schedule(() =&gt;
{
    errorMessageSpriteText.Text = exception.Message;
    errorMessageSpriteText.FadeTo(Colour4.Red).Then().FadeTo(Colour4.White, 1000);
});
</code></pre>
<p>While the above use case is to be considered the primary one for schedulers, they can also be used to handle a variety of other tasks, as well:</p>
<ul>
<li><p>If a drawable - for whatever reason - is not being actively updated (due to being not present, masked away, not loaded yet), scheduling a task onto it ensures that the task may execute on the nearest possible occasion when the drawable is back in the active scene graph.</p>
</li>
<li><p>The return value of a <code>Schedule()</code> call is a <code>ScheduledDelegate</code>, which can be later cancelled. This can be used to enqueue operations to be executed at some point in the future, but still be able to early-cancel them if some other condition is met.</p>
</li>
<li><p>Aside from <code>Schedule()</code>, the <code>Scheduler</code> itself is also exposed as protected on each drawable, and provides additional capabilities, such as:</p>
<ul>
<li><p><code>Scheduler.AddOnce(task)</code> can be used to ensure that an operation runs at most once per frame.
This is most often useful when called from an input event handler (whether mouse, keyboard, or any other peripheral), to avoid performing needless updates.</p>
</li>
<li><p><code>Scheduler.AddDelayed(task, timeUntilRun)</code> can be used to run an operation at a set time in the future, relative to now.
That method also has a <code>repeat</code> argument that can be used for recurring operations (they will execute regularly every <code>timeUntilRun</code> milliseconds).</p>
</li>
</ul>
</li>
<li><p>As a last-ditch attempt, schedulers can sometimes also be used to fix various one-frame issues, such as auto-size containers flickering when their contents are being changed.
This sort of usage is however discouraged, as it can cause headaches down the line due to complicating interactions between components.</p>
</li>
</ul>
<p>In general schedulers are a powerful tool, but ones that should be used carefully, as they change the usual flow of operations and therefore delay their effects.
Nesting schedules, or having chains of scheduled operations will complicate debugging significantly.</p>
<h2 id="audio-components">Audio components</h2>
<p>Note that when using <code>AudioComponent</code> and its derived classes (<code>SampleChannel</code>, <code>Track</code>) there is no inherent need to schedule operations like <code>Play()</code> or <code>Stop()</code>. The components themselves internally ensure that the operations to be executed are correctly enqueued onto the audio thread.</p>
<h1 id="asynchronous-disposal">Asynchronous disposal</h1>
<p>All drawables/components in a game, upon being removed from their parent <code>CompositeDrawable</code>s, are enqueued onto a game-global async disposal queue.
The queue uses TPL threadpool threads to run each of the drawables' <code>Dispose()</code> methods.</p>
<p>To suppress this behaviour, methods such as <code>CompositeDrawable.Remove()</code> or <code>CompositeDrawable.Clear(false)</code> can be used to remove a drawable from the hierarchy without calling its <code>Dispose()</code> implicitly.</p>
<h1 id="setting-thread-culture">Setting thread culture</h1>
<p>To change all of the main game threads to a new culture, you can set the <code>Locale</code> framework setting to the name of the desired locale, which should correspond to the value of <code>CultureInfo.Name</code> of the desired culture.
Doing this will change culture on all of the main threads, as well as set the default culture for any new threads.
Some existing threads not managed by the framework may still continue operating using the old culture, however.</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/ppy/osu-framework.wiki/blob/master/Threading.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          osu!framework is licensed under the MIT licence, docs powered by docfx
        </div>
      </div>
    </footer>
  </body>
</html>
